<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Engram — Cómo funciona</title>
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #18181c;
      --border: #2a2a30;
      --text: #e4e4e7;
      --muted: #a1a1aa;
      --accent: #a78bfa;
      --accent-dim: #7c3aed;
      --success: #34d399;
      --warning: #fbbf24;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      max-width: 720px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
    }
    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text);
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.95rem;
      margin-bottom: 2rem;
    }
    h2 {
      font-size: 1.2rem;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
      color: var(--accent);
    }
    p { margin: 0.75rem 0; color: var(--text); }
    ul, ol { margin: 0.75rem 0; padding-left: 1.5rem; }
    li { margin: 0.35rem 0; }
    code {
      background: var(--surface);
      padding: 0.15em 0.4em;
      border-radius: 4px;
      font-size: 0.9em;
      border: 1px solid var(--border);
    }
    .tool {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin: 0.75rem 0;
    }
    .tool-name { font-weight: 600; color: var(--accent); }
    .tool-desc { color: var(--muted); font-size: 0.9rem; margin-top: 0.25rem; }
    .badge {
      display: inline-block;
      font-size: 0.7rem;
      padding: 0.2em 0.5em;
      border-radius: 4px;
      background: var(--accent-dim);
      color: var(--text);
      margin-left: 0.5rem;
    }
    .flow {
      background: var(--surface);
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      border: 1px dashed var(--border);
    }
    .flow ol { margin: 0; padding-left: 1.25rem; }
    .flow li { margin: 0.5rem 0; }
    strong { color: var(--text); }
  </style>
</head>
<body>
  <h1>Engram — Cómo funciona</h1>
  <p class="subtitle">Memoria persistente para sesiones de código (MCP). La información sobrevive entre sesiones y compactions de contexto.</p>

  <h2>Qué es Engram</h2>
  <p>Engram es un servidor MCP que ofrece <strong>memoria persistente</strong>: guarda decisiones, bugs resueltos, patrones y descubrimientos para que futuras sesiones (y el agente) puedan recuperarlos. Sirve para no perder contexto cuando cambias de chat o se compacta el historial.</p>

  <h2>Flujo típico de una sesión</h2>
  <div class="flow">
    <ol>
      <li><strong>Inicio:</strong> <code>mem_session_start</code> — Registrar que empieza una nueva sesión (id, proyecto, directorio).</li>
      <li><strong>Durante la sesión:</strong> <code>mem_save</code> — Guardar observaciones importantes (decisiones, bugfixes, patrones, config, descubrimientos).</li>
      <li><strong>Recuperar contexto:</strong> <code>mem_context</code> o <code>mem_search</code> — Ver qué se hizo antes o buscar por palabras clave.</li>
      <li><strong>Al terminar:</strong> <code>mem_session_summary</code> y <code>mem_session_end</code> — Resumir lo logrado y cerrar la sesión.</li>
    </ol>
  </div>

  <h2>Herramientas principales</h2>

  <div class="tool">
    <span class="tool-name">mem_session_start</span>
    <p class="tool-desc">Registra el inicio de una nueva sesión de código (id, proyecto, directorio opcional). Úsalo al comenzar.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_session_end</span>
    <p class="tool-desc">Marca la sesión como terminada. Opcionalmente puedes pasar un resumen de lo logrado.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_session_summary</span>
    <p class="tool-desc">Guarda un resumen estructurado del final de la sesión (objetivo, instrucciones, descubrimientos, tareas hechas, archivos relevantes). Lo usan sesiones futuras para entender qué pasó.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_save</span> <span class="badge">clave</span>
    <p class="tool-desc">Guarda una observación en memoria persistente. Conviene usarlo después de trabajo relevante: decisiones de arquitectura, corrección de bugs, nuevos patrones, cambios de config, descubrimientos. Formato sugerido: <strong>What / Why / Where / Learned</strong>. Tipos: decision, architecture, bugfix, pattern, config, discovery, learning.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_search</span>
    <p class="tool-desc">Busca en la memoria persistente (todas las sesiones). Sirve para encontrar decisiones pasadas, bugs corregidos, patrones o contexto por palabras clave. Se puede filtrar por proyecto, scope (project/personal) y tipo.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_context</span>
    <p class="tool-desc">Obtiene contexto reciente de sesiones anteriores: sesiones y observaciones recientes para entender qué se hizo antes. Opcional: proyecto, scope y límite de resultados.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_get_observation</span>
    <p class="tool-desc">Devuelve el contenido completo de una observación por ID (útil tras <code>mem_search</code> cuando necesitas el texto completo).</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_save_prompt</span>
    <p class="tool-desc">Guarda el prompt del usuario en memoria. Sirve para recordar intención, preguntas y peticiones y dar contexto a futuras sesiones.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_suggest_topic_key</span>
    <p class="tool-desc">Sugiere un <code>topic_key</code> estable para hacer upserts. Úsalo antes de <code>mem_save</code> cuando un tema evoluciona (ej. decisiones de arquitectura) y quieres actualizar una sola observación en el tiempo.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_update</span>
    <p class="tool-desc">Actualiza una observación existente por ID. Solo se modifican los campos que envíes.</p>
  </div>

  <div class="tool">
    <span class="tool-name">mem_capture_passive</span>
    <p class="tool-desc">Extrae y guarda aprendizajes estructurados de un texto. Busca secciones como "## Key Learnings:" o "## Aprendizajes Clave:" con ítems numerados o con viñetas y los guarda como observaciones. Evita duplicados.</p>
  </div>

  <h2>Cuándo usar qué</h2>
  <ul>
    <li><strong>Guardar decisiones/bugs/patrones:</strong> <code>mem_save</code> con título corto y contenido en formato What/Why/Where/Learned.</li>
    <li><strong>Recordar qué pediste:</strong> <code>mem_save_prompt</code>.</li>
    <li><strong>Recuperar contexto al empezar:</strong> <code>mem_context</code> o <code>mem_search</code> con query en lenguaje natural.</li>
    <li><strong>Cerrar sesión con resumen:</strong> <code>mem_session_summary</code> y luego <code>mem_session_end</code>.</li>
  </ul>

  <h2>Resumen</h2>
  <p>Engram mantiene una memoria persistente entre sesiones: <strong>mem_session_start</strong> y <strong>mem_session_end</strong> marcan el ciclo de vida; <strong>mem_save</strong> y <strong>mem_session_summary</strong> alimentan la memoria; <strong>mem_search</strong> y <strong>mem_context</strong> la consultan. Así el agente y tú podéis seguir el hilo de decisiones, bugs y aprendizajes sin depender solo del historial del chat.</p>
</body>
</html>
